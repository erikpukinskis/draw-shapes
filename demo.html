<html><body>

<style>
canvas {
  border: 1px solid #eee;
}
</style>
<script src="../build/gl-matrix.js"></script>
<script src="../build/draw-scene.js"></script>

<canvas width="400" height="400" onmousedown="down(event)"></canvas>

<script>

var handleMove

var strokes = []
var triangles = []

function down(event) {
  var point = [event.clientX, event.clientY]

  for(var i=0; i<triangles.length; i++) {
    var triangle = triangles[i]

    var testPoint = [point[0], -point[1], 0.0]

    if (pointInTriangle(testPoint, triangle)) {
      var stroke = triangle[3]
      continue
    }
  }

  if (stroke) {
    console.log("budge it!")
  } else {
    console.log("not in it")
    startShape(point)
  }
}


function sameSide(p1,p2, a,b) {
    var xa = []
    var xb = []
    var xb2 = []
    var cp1 = []
    var cp2 = []

    vec3.subtract(xa, b, a)
    vec3.subtract(xb, p1, a)
    vec3.cross(cp1, xa, xb)

    vec3.subtract(xb2, p2, a)
    vec3.cross(cp2, xa, xb2)

    var isSame = vec3.dot(cp1, cp2) >= 0

    return isSame
}


function fastPointInTriangle(p, triangle) {

  // from http://www.blackpawn.com/texts/pointinpoly/

  var a = triangle[0] 
  var b = triangle[1] 
  var c = triangle[2] 

  var isInside =
    sameSide(p,a, b,c) 
    && sameSide(p,b, a,c)
    && sameSide(p,c, a,b)

  return isInside
}

var p = [2,1,0]
var a = [1,1,0]
var b = [2,3,0]
var c = [4,1,0]

pointInTriangle(p, [a,b,c])

function pointInTriangle(p, triangle) {
  
  var a = triangle[0]
  var b = triangle[1] 
  var c = triangle[2] 

  var probeA = []
  var probeB = []
  var probeC = []

  vec3.subtract(probeA, a, p)
  vec3.subtract(probeB, b, p)
  vec3.subtract(probeC, c, p)

  var angles = [
    vec3.angle(probeA, probeB),
    vec3.angle(probeB, probeC),
    vec3.angle(probeC, probeA),
  ]

  var totalAngle =
    vec3.angle(probeA, probeB)
    + vec3.angle(probeB, probeC)
    + vec3.angle(probeC, probeA)

  var isInside = 2*Math.PI - totalAngle < 0.01

  return isInside
}




function startShape(point) {
  var stroke = {
    path: [point]
  }

  strokes.push(stroke)

  handleMove = addPoint.bind(null, stroke.path)
  handleUp = finishShape.bind(null, stroke.path)
}

function addPoint(path, event) {
  path.push([event.clientX, event.clientY])

  drawStrokes()
}

function drawStrokes() {
  var shapes = []
  triangles = []
  strokes.forEach(function(stroke) {
    shapes = shapes.concat(pathToShapes(stroke))
  })

  drawScene(shapes)
}

var shapes = []

function finishShape(path, event) {
  handleMove = null
  handleUp = null
}

function pathToShapes(stroke) {
  var path = stroke.path

  var last = path.length-1

  var firstPoint = [
    path[0][0], 
    -path[0][1],
    0.0
  ]

  var lastPoint = [
    path[last][0],
    -path[last][1],
    0.0
  ]

  var out = []
  var midPoint = []
  var otherMidPoint = []

  vec3.subtract(out, lastPoint, firstPoint)

  vec3.scale(out, out, 0.5)

  vec3.add(out, firstPoint, out)

  var distance = vec3.distance(firstPoint, lastPoint)

  var thickness = (7 - Math.log(distance)) / 8.0

  vec3.rotateZ(midPoint, out, firstPoint, thickness)

  vec3.rotateZ(otherMidPoint, out, firstPoint, -thickness)

  triangles.push([firstPoint, midPoint, lastPoint, stroke])

  triangles.push([firstPoint, otherMidPoint, lastPoint, stroke])

  return [
    triangle(firstPoint, midPoint, lastPoint),
    triangle(firstPoint, otherMidPoint, lastPoint)
  ]
}

function triangle(a,b,c) {
  return {
    position: [0.0, 0.0, 0.0],
    verticies: a.concat(b,c),
    pointCount: 3,
    colors: [
      1.0, 0.4, 0.6, 1.0,
      0.9, 0.4, 0.7, 1.0,
      0.8, 0.4, 0.9, 1.0
    ]
  }

}


var camera = {
  fovy: 45,
  near: 0.1,
  far: 600.0,
  pitch: 0.0,
  yaw: 0.0,
  xPos: -205.0,
  yPos: 205.0,
  zPos: -340.0  
}

drawScene.init(camera)

window.onmousemove = function(event) {
  if (!handleMove) { return }
  handleMove(event)
}

window.onmouseup = function(event) {
  if (!handleUp) { return }
  handleUp(event)
}

</script>

</body></html>